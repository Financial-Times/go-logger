// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logger

import (
	"sync"
	"time"
)

// Ensure, that LogEntryMock does implement LogEntry.
// If this is not the case, regenerate this file with moq.
var _ LogEntry = &LogEntryMock{}

// LogEntryMock is a mock implementation of LogEntry.
//
// 	func TestSomethingThatUsesLogEntry(t *testing.T) {
//
// 		// make and configure a mocked LogEntry
// 		mockedLogEntry := &LogEntryMock{
// 			DebugFunc: func(args ...interface{})  {
// 				panic("mock out the Debug method")
// 			},
// 			DebugfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Debugf method")
// 			},
// 			DebuglnFunc: func(args ...interface{})  {
// 				panic("mock out the Debugln method")
// 			},
// 			ErrorFunc: func(args ...interface{})  {
// 				panic("mock out the Error method")
// 			},
// 			ErrorfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Errorf method")
// 			},
// 			ErrorlnFunc: func(args ...interface{})  {
// 				panic("mock out the Errorln method")
// 			},
// 			FatalFunc: func(args ...interface{})  {
// 				panic("mock out the Fatal method")
// 			},
// 			FatalfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Fatalf method")
// 			},
// 			FatallnFunc: func(args ...interface{})  {
// 				panic("mock out the Fatalln method")
// 			},
// 			InfoFunc: func(args ...interface{})  {
// 				panic("mock out the Info method")
// 			},
// 			InfofFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Infof method")
// 			},
// 			InfolnFunc: func(args ...interface{})  {
// 				panic("mock out the Infoln method")
// 			},
// 			PanicFunc: func(args ...interface{})  {
// 				panic("mock out the Panic method")
// 			},
// 			PanicfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Panicf method")
// 			},
// 			PaniclnFunc: func(args ...interface{})  {
// 				panic("mock out the Panicln method")
// 			},
// 			PrintFunc: func(args ...interface{})  {
// 				panic("mock out the Print method")
// 			},
// 			PrintfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Printf method")
// 			},
// 			PrintlnFunc: func(args ...interface{})  {
// 				panic("mock out the Println method")
// 			},
// 			WarnFunc: func(args ...interface{})  {
// 				panic("mock out the Warn method")
// 			},
// 			WarnfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Warnf method")
// 			},
// 			WarningFunc: func(args ...interface{})  {
// 				panic("mock out the Warning method")
// 			},
// 			WarningfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Warningf method")
// 			},
// 			WarninglnFunc: func(args ...interface{})  {
// 				panic("mock out the Warningln method")
// 			},
// 			WarnlnFunc: func(args ...interface{})  {
// 				panic("mock out the Warnln method")
// 			},
// 			WithCategorisedEventFunc: func(s1 string, s2 string, s3 string, s4 string) LogEntry {
// 				panic("mock out the WithCategorisedEvent method")
// 			},
// 			WithErrorFunc: func(err error) LogEntry {
// 				panic("mock out the WithError method")
// 			},
// 			WithFieldFunc: func(s string, ifaceVal interface{}) LogEntry {
// 				panic("mock out the WithField method")
// 			},
// 			WithFieldsFunc: func(stringToIfaceVal map[string]interface{}) LogEntry {
// 				panic("mock out the WithFields method")
// 			},
// 			WithMonitoringEventFunc: func(s1 string, s2 string, s3 string) LogEntry {
// 				panic("mock out the WithMonitoringEvent method")
// 			},
// 			WithTimeFunc: func(timeMoqParam time.Time) LogEntry {
// 				panic("mock out the WithTime method")
// 			},
// 			WithTransactionIDFunc: func(s string) LogEntry {
// 				panic("mock out the WithTransactionID method")
// 			},
// 			WithUUIDFunc: func(s string) LogEntry {
// 				panic("mock out the WithUUID method")
// 			},
// 			WithValidFlagFunc: func(b bool) LogEntry {
// 				panic("mock out the WithValidFlag method")
// 			},
// 		}
//
// 		// use mockedLogEntry in code that requires LogEntry
// 		// and then make assertions.
//
// 	}
type LogEntryMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(args ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, args ...interface{})

	// DebuglnFunc mocks the Debugln method.
	DebuglnFunc func(args ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(args ...interface{})

	// ErrorfFunc mocks the Errorf method.
	ErrorfFunc func(format string, args ...interface{})

	// ErrorlnFunc mocks the Errorln method.
	ErrorlnFunc func(args ...interface{})

	// FatalFunc mocks the Fatal method.
	FatalFunc func(args ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, args ...interface{})

	// FatallnFunc mocks the Fatalln method.
	FatallnFunc func(args ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(args ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, args ...interface{})

	// InfolnFunc mocks the Infoln method.
	InfolnFunc func(args ...interface{})

	// PanicFunc mocks the Panic method.
	PanicFunc func(args ...interface{})

	// PanicfFunc mocks the Panicf method.
	PanicfFunc func(format string, args ...interface{})

	// PaniclnFunc mocks the Panicln method.
	PaniclnFunc func(args ...interface{})

	// PrintFunc mocks the Print method.
	PrintFunc func(args ...interface{})

	// PrintfFunc mocks the Printf method.
	PrintfFunc func(format string, args ...interface{})

	// PrintlnFunc mocks the Println method.
	PrintlnFunc func(args ...interface{})

	// WarnFunc mocks the Warn method.
	WarnFunc func(args ...interface{})

	// WarnfFunc mocks the Warnf method.
	WarnfFunc func(format string, args ...interface{})

	// WarningFunc mocks the Warning method.
	WarningFunc func(args ...interface{})

	// WarningfFunc mocks the Warningf method.
	WarningfFunc func(format string, args ...interface{})

	// WarninglnFunc mocks the Warningln method.
	WarninglnFunc func(args ...interface{})

	// WarnlnFunc mocks the Warnln method.
	WarnlnFunc func(args ...interface{})

	// WithCategorisedEventFunc mocks the WithCategorisedEvent method.
	WithCategorisedEventFunc func(s1 string, s2 string, s3 string, s4 string) LogEntry

	// WithErrorFunc mocks the WithError method.
	WithErrorFunc func(err error) LogEntry

	// WithFieldFunc mocks the WithField method.
	WithFieldFunc func(s string, ifaceVal interface{}) LogEntry

	// WithFieldsFunc mocks the WithFields method.
	WithFieldsFunc func(stringToIfaceVal map[string]interface{}) LogEntry

	// WithMonitoringEventFunc mocks the WithMonitoringEvent method.
	WithMonitoringEventFunc func(s1 string, s2 string, s3 string) LogEntry

	// WithTimeFunc mocks the WithTime method.
	WithTimeFunc func(timeMoqParam time.Time) LogEntry

	// WithTransactionIDFunc mocks the WithTransactionID method.
	WithTransactionIDFunc func(s string) LogEntry

	// WithUUIDFunc mocks the WithUUID method.
	WithUUIDFunc func(s string) LogEntry

	// WithValidFlagFunc mocks the WithValidFlag method.
	WithValidFlagFunc func(b bool) LogEntry

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Debugln holds details about calls to the Debugln method.
		Debugln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Errorf holds details about calls to the Errorf method.
		Errorf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Errorln holds details about calls to the Errorln method.
		Errorln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatalln holds details about calls to the Fatalln method.
		Fatalln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Infoln holds details about calls to the Infoln method.
		Infoln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Panic holds details about calls to the Panic method.
		Panic []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Panicf holds details about calls to the Panicf method.
		Panicf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Panicln holds details about calls to the Panicln method.
		Panicln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Printf holds details about calls to the Printf method.
		Printf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Println holds details about calls to the Println method.
		Println []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Warn holds details about calls to the Warn method.
		Warn []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Warnf holds details about calls to the Warnf method.
		Warnf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Warning holds details about calls to the Warning method.
		Warning []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Warningf holds details about calls to the Warningf method.
		Warningf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Warningln holds details about calls to the Warningln method.
		Warningln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Warnln holds details about calls to the Warnln method.
		Warnln []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// WithCategorisedEvent holds details about calls to the WithCategorisedEvent method.
		WithCategorisedEvent []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
			// S3 is the s3 argument value.
			S3 string
			// S4 is the s4 argument value.
			S4 string
		}
		// WithError holds details about calls to the WithError method.
		WithError []struct {
			// Err is the err argument value.
			Err error
		}
		// WithField holds details about calls to the WithField method.
		WithField []struct {
			// S is the s argument value.
			S string
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
		// WithFields holds details about calls to the WithFields method.
		WithFields []struct {
			// StringToIfaceVal is the stringToIfaceVal argument value.
			StringToIfaceVal map[string]interface{}
		}
		// WithMonitoringEvent holds details about calls to the WithMonitoringEvent method.
		WithMonitoringEvent []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
			// S3 is the s3 argument value.
			S3 string
		}
		// WithTime holds details about calls to the WithTime method.
		WithTime []struct {
			// TimeMoqParam is the timeMoqParam argument value.
			TimeMoqParam time.Time
		}
		// WithTransactionID holds details about calls to the WithTransactionID method.
		WithTransactionID []struct {
			// S is the s argument value.
			S string
		}
		// WithUUID holds details about calls to the WithUUID method.
		WithUUID []struct {
			// S is the s argument value.
			S string
		}
		// WithValidFlag holds details about calls to the WithValidFlag method.
		WithValidFlag []struct {
			// B is the b argument value.
			B bool
		}
	}
	lockDebug                sync.RWMutex
	lockDebugf               sync.RWMutex
	lockDebugln              sync.RWMutex
	lockError                sync.RWMutex
	lockErrorf               sync.RWMutex
	lockErrorln              sync.RWMutex
	lockFatal                sync.RWMutex
	lockFatalf               sync.RWMutex
	lockFatalln              sync.RWMutex
	lockInfo                 sync.RWMutex
	lockInfof                sync.RWMutex
	lockInfoln               sync.RWMutex
	lockPanic                sync.RWMutex
	lockPanicf               sync.RWMutex
	lockPanicln              sync.RWMutex
	lockPrint                sync.RWMutex
	lockPrintf               sync.RWMutex
	lockPrintln              sync.RWMutex
	lockWarn                 sync.RWMutex
	lockWarnf                sync.RWMutex
	lockWarning              sync.RWMutex
	lockWarningf             sync.RWMutex
	lockWarningln            sync.RWMutex
	lockWarnln               sync.RWMutex
	lockWithCategorisedEvent sync.RWMutex
	lockWithError            sync.RWMutex
	lockWithField            sync.RWMutex
	lockWithFields           sync.RWMutex
	lockWithMonitoringEvent  sync.RWMutex
	lockWithTime             sync.RWMutex
	lockWithTransactionID    sync.RWMutex
	lockWithUUID             sync.RWMutex
	lockWithValidFlag        sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LogEntryMock) Debug(args ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LogEntryMock.DebugFunc: method is nil but LogEntry.Debug was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//     len(mockedLogEntry.DebugCalls())
func (mock *LogEntryMock) DebugCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LogEntryMock) Debugf(format string, args ...interface{}) {
	if mock.DebugfFunc == nil {
		panic("LogEntryMock.DebugfFunc: method is nil but LogEntry.Debugf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	mock.lockDebugf.Unlock()
	mock.DebugfFunc(format, args...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//     len(mockedLogEntry.DebugfCalls())
func (mock *LogEntryMock) DebugfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockDebugf.RLock()
	calls = mock.calls.Debugf
	mock.lockDebugf.RUnlock()
	return calls
}

// Debugln calls DebuglnFunc.
func (mock *LogEntryMock) Debugln(args ...interface{}) {
	if mock.DebuglnFunc == nil {
		panic("LogEntryMock.DebuglnFunc: method is nil but LogEntry.Debugln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDebugln.Lock()
	mock.calls.Debugln = append(mock.calls.Debugln, callInfo)
	mock.lockDebugln.Unlock()
	mock.DebuglnFunc(args...)
}

// DebuglnCalls gets all the calls that were made to Debugln.
// Check the length with:
//     len(mockedLogEntry.DebuglnCalls())
func (mock *LogEntryMock) DebuglnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDebugln.RLock()
	calls = mock.calls.Debugln
	mock.lockDebugln.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LogEntryMock) Error(args ...interface{}) {
	if mock.ErrorFunc == nil {
		panic("LogEntryMock.ErrorFunc: method is nil but LogEntry.Error was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//     len(mockedLogEntry.ErrorCalls())
func (mock *LogEntryMock) ErrorCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errorf calls ErrorfFunc.
func (mock *LogEntryMock) Errorf(format string, args ...interface{}) {
	if mock.ErrorfFunc == nil {
		panic("LogEntryMock.ErrorfFunc: method is nil but LogEntry.Errorf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockErrorf.Lock()
	mock.calls.Errorf = append(mock.calls.Errorf, callInfo)
	mock.lockErrorf.Unlock()
	mock.ErrorfFunc(format, args...)
}

// ErrorfCalls gets all the calls that were made to Errorf.
// Check the length with:
//     len(mockedLogEntry.ErrorfCalls())
func (mock *LogEntryMock) ErrorfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockErrorf.RLock()
	calls = mock.calls.Errorf
	mock.lockErrorf.RUnlock()
	return calls
}

// Errorln calls ErrorlnFunc.
func (mock *LogEntryMock) Errorln(args ...interface{}) {
	if mock.ErrorlnFunc == nil {
		panic("LogEntryMock.ErrorlnFunc: method is nil but LogEntry.Errorln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockErrorln.Lock()
	mock.calls.Errorln = append(mock.calls.Errorln, callInfo)
	mock.lockErrorln.Unlock()
	mock.ErrorlnFunc(args...)
}

// ErrorlnCalls gets all the calls that were made to Errorln.
// Check the length with:
//     len(mockedLogEntry.ErrorlnCalls())
func (mock *LogEntryMock) ErrorlnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockErrorln.RLock()
	calls = mock.calls.Errorln
	mock.lockErrorln.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LogEntryMock) Fatal(args ...interface{}) {
	if mock.FatalFunc == nil {
		panic("LogEntryMock.FatalFunc: method is nil but LogEntry.Fatal was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	mock.lockFatal.Unlock()
	mock.FatalFunc(args...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//     len(mockedLogEntry.FatalCalls())
func (mock *LogEntryMock) FatalCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockFatal.RLock()
	calls = mock.calls.Fatal
	mock.lockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LogEntryMock) Fatalf(format string, args ...interface{}) {
	if mock.FatalfFunc == nil {
		panic("LogEntryMock.FatalfFunc: method is nil but LogEntry.Fatalf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	mock.lockFatalf.Unlock()
	mock.FatalfFunc(format, args...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//     len(mockedLogEntry.FatalfCalls())
func (mock *LogEntryMock) FatalfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockFatalf.RLock()
	calls = mock.calls.Fatalf
	mock.lockFatalf.RUnlock()
	return calls
}

// Fatalln calls FatallnFunc.
func (mock *LogEntryMock) Fatalln(args ...interface{}) {
	if mock.FatallnFunc == nil {
		panic("LogEntryMock.FatallnFunc: method is nil but LogEntry.Fatalln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockFatalln.Lock()
	mock.calls.Fatalln = append(mock.calls.Fatalln, callInfo)
	mock.lockFatalln.Unlock()
	mock.FatallnFunc(args...)
}

// FatallnCalls gets all the calls that were made to Fatalln.
// Check the length with:
//     len(mockedLogEntry.FatallnCalls())
func (mock *LogEntryMock) FatallnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockFatalln.RLock()
	calls = mock.calls.Fatalln
	mock.lockFatalln.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LogEntryMock) Info(args ...interface{}) {
	if mock.InfoFunc == nil {
		panic("LogEntryMock.InfoFunc: method is nil but LogEntry.Info was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedLogEntry.InfoCalls())
func (mock *LogEntryMock) InfoCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LogEntryMock) Infof(format string, args ...interface{}) {
	if mock.InfofFunc == nil {
		panic("LogEntryMock.InfofFunc: method is nil but LogEntry.Infof was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	mock.InfofFunc(format, args...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//     len(mockedLogEntry.InfofCalls())
func (mock *LogEntryMock) InfofCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}

// Infoln calls InfolnFunc.
func (mock *LogEntryMock) Infoln(args ...interface{}) {
	if mock.InfolnFunc == nil {
		panic("LogEntryMock.InfolnFunc: method is nil but LogEntry.Infoln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfoln.Lock()
	mock.calls.Infoln = append(mock.calls.Infoln, callInfo)
	mock.lockInfoln.Unlock()
	mock.InfolnFunc(args...)
}

// InfolnCalls gets all the calls that were made to Infoln.
// Check the length with:
//     len(mockedLogEntry.InfolnCalls())
func (mock *LogEntryMock) InfolnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfoln.RLock()
	calls = mock.calls.Infoln
	mock.lockInfoln.RUnlock()
	return calls
}

// Panic calls PanicFunc.
func (mock *LogEntryMock) Panic(args ...interface{}) {
	if mock.PanicFunc == nil {
		panic("LogEntryMock.PanicFunc: method is nil but LogEntry.Panic was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPanic.Lock()
	mock.calls.Panic = append(mock.calls.Panic, callInfo)
	mock.lockPanic.Unlock()
	mock.PanicFunc(args...)
}

// PanicCalls gets all the calls that were made to Panic.
// Check the length with:
//     len(mockedLogEntry.PanicCalls())
func (mock *LogEntryMock) PanicCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPanic.RLock()
	calls = mock.calls.Panic
	mock.lockPanic.RUnlock()
	return calls
}

// Panicf calls PanicfFunc.
func (mock *LogEntryMock) Panicf(format string, args ...interface{}) {
	if mock.PanicfFunc == nil {
		panic("LogEntryMock.PanicfFunc: method is nil but LogEntry.Panicf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPanicf.Lock()
	mock.calls.Panicf = append(mock.calls.Panicf, callInfo)
	mock.lockPanicf.Unlock()
	mock.PanicfFunc(format, args...)
}

// PanicfCalls gets all the calls that were made to Panicf.
// Check the length with:
//     len(mockedLogEntry.PanicfCalls())
func (mock *LogEntryMock) PanicfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPanicf.RLock()
	calls = mock.calls.Panicf
	mock.lockPanicf.RUnlock()
	return calls
}

// Panicln calls PaniclnFunc.
func (mock *LogEntryMock) Panicln(args ...interface{}) {
	if mock.PaniclnFunc == nil {
		panic("LogEntryMock.PaniclnFunc: method is nil but LogEntry.Panicln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPanicln.Lock()
	mock.calls.Panicln = append(mock.calls.Panicln, callInfo)
	mock.lockPanicln.Unlock()
	mock.PaniclnFunc(args...)
}

// PaniclnCalls gets all the calls that were made to Panicln.
// Check the length with:
//     len(mockedLogEntry.PaniclnCalls())
func (mock *LogEntryMock) PaniclnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPanicln.RLock()
	calls = mock.calls.Panicln
	mock.lockPanicln.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LogEntryMock) Print(args ...interface{}) {
	if mock.PrintFunc == nil {
		panic("LogEntryMock.PrintFunc: method is nil but LogEntry.Print was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//     len(mockedLogEntry.PrintCalls())
func (mock *LogEntryMock) PrintCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Printf calls PrintfFunc.
func (mock *LogEntryMock) Printf(format string, args ...interface{}) {
	if mock.PrintfFunc == nil {
		panic("LogEntryMock.PrintfFunc: method is nil but LogEntry.Printf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintf.Lock()
	mock.calls.Printf = append(mock.calls.Printf, callInfo)
	mock.lockPrintf.Unlock()
	mock.PrintfFunc(format, args...)
}

// PrintfCalls gets all the calls that were made to Printf.
// Check the length with:
//     len(mockedLogEntry.PrintfCalls())
func (mock *LogEntryMock) PrintfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPrintf.RLock()
	calls = mock.calls.Printf
	mock.lockPrintf.RUnlock()
	return calls
}

// Println calls PrintlnFunc.
func (mock *LogEntryMock) Println(args ...interface{}) {
	if mock.PrintlnFunc == nil {
		panic("LogEntryMock.PrintlnFunc: method is nil but LogEntry.Println was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPrintln.Lock()
	mock.calls.Println = append(mock.calls.Println, callInfo)
	mock.lockPrintln.Unlock()
	mock.PrintlnFunc(args...)
}

// PrintlnCalls gets all the calls that were made to Println.
// Check the length with:
//     len(mockedLogEntry.PrintlnCalls())
func (mock *LogEntryMock) PrintlnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPrintln.RLock()
	calls = mock.calls.Println
	mock.lockPrintln.RUnlock()
	return calls
}

// Warn calls WarnFunc.
func (mock *LogEntryMock) Warn(args ...interface{}) {
	if mock.WarnFunc == nil {
		panic("LogEntryMock.WarnFunc: method is nil but LogEntry.Warn was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockWarn.Lock()
	mock.calls.Warn = append(mock.calls.Warn, callInfo)
	mock.lockWarn.Unlock()
	mock.WarnFunc(args...)
}

// WarnCalls gets all the calls that were made to Warn.
// Check the length with:
//     len(mockedLogEntry.WarnCalls())
func (mock *LogEntryMock) WarnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockWarn.RLock()
	calls = mock.calls.Warn
	mock.lockWarn.RUnlock()
	return calls
}

// Warnf calls WarnfFunc.
func (mock *LogEntryMock) Warnf(format string, args ...interface{}) {
	if mock.WarnfFunc == nil {
		panic("LogEntryMock.WarnfFunc: method is nil but LogEntry.Warnf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockWarnf.Lock()
	mock.calls.Warnf = append(mock.calls.Warnf, callInfo)
	mock.lockWarnf.Unlock()
	mock.WarnfFunc(format, args...)
}

// WarnfCalls gets all the calls that were made to Warnf.
// Check the length with:
//     len(mockedLogEntry.WarnfCalls())
func (mock *LogEntryMock) WarnfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockWarnf.RLock()
	calls = mock.calls.Warnf
	mock.lockWarnf.RUnlock()
	return calls
}

// Warning calls WarningFunc.
func (mock *LogEntryMock) Warning(args ...interface{}) {
	if mock.WarningFunc == nil {
		panic("LogEntryMock.WarningFunc: method is nil but LogEntry.Warning was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockWarning.Lock()
	mock.calls.Warning = append(mock.calls.Warning, callInfo)
	mock.lockWarning.Unlock()
	mock.WarningFunc(args...)
}

// WarningCalls gets all the calls that were made to Warning.
// Check the length with:
//     len(mockedLogEntry.WarningCalls())
func (mock *LogEntryMock) WarningCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockWarning.RLock()
	calls = mock.calls.Warning
	mock.lockWarning.RUnlock()
	return calls
}

// Warningf calls WarningfFunc.
func (mock *LogEntryMock) Warningf(format string, args ...interface{}) {
	if mock.WarningfFunc == nil {
		panic("LogEntryMock.WarningfFunc: method is nil but LogEntry.Warningf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockWarningf.Lock()
	mock.calls.Warningf = append(mock.calls.Warningf, callInfo)
	mock.lockWarningf.Unlock()
	mock.WarningfFunc(format, args...)
}

// WarningfCalls gets all the calls that were made to Warningf.
// Check the length with:
//     len(mockedLogEntry.WarningfCalls())
func (mock *LogEntryMock) WarningfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockWarningf.RLock()
	calls = mock.calls.Warningf
	mock.lockWarningf.RUnlock()
	return calls
}

// Warningln calls WarninglnFunc.
func (mock *LogEntryMock) Warningln(args ...interface{}) {
	if mock.WarninglnFunc == nil {
		panic("LogEntryMock.WarninglnFunc: method is nil but LogEntry.Warningln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockWarningln.Lock()
	mock.calls.Warningln = append(mock.calls.Warningln, callInfo)
	mock.lockWarningln.Unlock()
	mock.WarninglnFunc(args...)
}

// WarninglnCalls gets all the calls that were made to Warningln.
// Check the length with:
//     len(mockedLogEntry.WarninglnCalls())
func (mock *LogEntryMock) WarninglnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockWarningln.RLock()
	calls = mock.calls.Warningln
	mock.lockWarningln.RUnlock()
	return calls
}

// Warnln calls WarnlnFunc.
func (mock *LogEntryMock) Warnln(args ...interface{}) {
	if mock.WarnlnFunc == nil {
		panic("LogEntryMock.WarnlnFunc: method is nil but LogEntry.Warnln was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockWarnln.Lock()
	mock.calls.Warnln = append(mock.calls.Warnln, callInfo)
	mock.lockWarnln.Unlock()
	mock.WarnlnFunc(args...)
}

// WarnlnCalls gets all the calls that were made to Warnln.
// Check the length with:
//     len(mockedLogEntry.WarnlnCalls())
func (mock *LogEntryMock) WarnlnCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockWarnln.RLock()
	calls = mock.calls.Warnln
	mock.lockWarnln.RUnlock()
	return calls
}

// WithCategorisedEvent calls WithCategorisedEventFunc.
func (mock *LogEntryMock) WithCategorisedEvent(s1 string, s2 string, s3 string, s4 string) LogEntry {
	if mock.WithCategorisedEventFunc == nil {
		panic("LogEntryMock.WithCategorisedEventFunc: method is nil but LogEntry.WithCategorisedEvent was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
		S3 string
		S4 string
	}{
		S1: s1,
		S2: s2,
		S3: s3,
		S4: s4,
	}
	mock.lockWithCategorisedEvent.Lock()
	mock.calls.WithCategorisedEvent = append(mock.calls.WithCategorisedEvent, callInfo)
	mock.lockWithCategorisedEvent.Unlock()
	return mock.WithCategorisedEventFunc(s1, s2, s3, s4)
}

// WithCategorisedEventCalls gets all the calls that were made to WithCategorisedEvent.
// Check the length with:
//     len(mockedLogEntry.WithCategorisedEventCalls())
func (mock *LogEntryMock) WithCategorisedEventCalls() []struct {
	S1 string
	S2 string
	S3 string
	S4 string
} {
	var calls []struct {
		S1 string
		S2 string
		S3 string
		S4 string
	}
	mock.lockWithCategorisedEvent.RLock()
	calls = mock.calls.WithCategorisedEvent
	mock.lockWithCategorisedEvent.RUnlock()
	return calls
}

// WithError calls WithErrorFunc.
func (mock *LogEntryMock) WithError(err error) LogEntry {
	if mock.WithErrorFunc == nil {
		panic("LogEntryMock.WithErrorFunc: method is nil but LogEntry.WithError was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockWithError.Lock()
	mock.calls.WithError = append(mock.calls.WithError, callInfo)
	mock.lockWithError.Unlock()
	return mock.WithErrorFunc(err)
}

// WithErrorCalls gets all the calls that were made to WithError.
// Check the length with:
//     len(mockedLogEntry.WithErrorCalls())
func (mock *LogEntryMock) WithErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockWithError.RLock()
	calls = mock.calls.WithError
	mock.lockWithError.RUnlock()
	return calls
}

// WithField calls WithFieldFunc.
func (mock *LogEntryMock) WithField(s string, ifaceVal interface{}) LogEntry {
	if mock.WithFieldFunc == nil {
		panic("LogEntryMock.WithFieldFunc: method is nil but LogEntry.WithField was just called")
	}
	callInfo := struct {
		S        string
		IfaceVal interface{}
	}{
		S:        s,
		IfaceVal: ifaceVal,
	}
	mock.lockWithField.Lock()
	mock.calls.WithField = append(mock.calls.WithField, callInfo)
	mock.lockWithField.Unlock()
	return mock.WithFieldFunc(s, ifaceVal)
}

// WithFieldCalls gets all the calls that were made to WithField.
// Check the length with:
//     len(mockedLogEntry.WithFieldCalls())
func (mock *LogEntryMock) WithFieldCalls() []struct {
	S        string
	IfaceVal interface{}
} {
	var calls []struct {
		S        string
		IfaceVal interface{}
	}
	mock.lockWithField.RLock()
	calls = mock.calls.WithField
	mock.lockWithField.RUnlock()
	return calls
}

// WithFields calls WithFieldsFunc.
func (mock *LogEntryMock) WithFields(stringToIfaceVal map[string]interface{}) LogEntry {
	if mock.WithFieldsFunc == nil {
		panic("LogEntryMock.WithFieldsFunc: method is nil but LogEntry.WithFields was just called")
	}
	callInfo := struct {
		StringToIfaceVal map[string]interface{}
	}{
		StringToIfaceVal: stringToIfaceVal,
	}
	mock.lockWithFields.Lock()
	mock.calls.WithFields = append(mock.calls.WithFields, callInfo)
	mock.lockWithFields.Unlock()
	return mock.WithFieldsFunc(stringToIfaceVal)
}

// WithFieldsCalls gets all the calls that were made to WithFields.
// Check the length with:
//     len(mockedLogEntry.WithFieldsCalls())
func (mock *LogEntryMock) WithFieldsCalls() []struct {
	StringToIfaceVal map[string]interface{}
} {
	var calls []struct {
		StringToIfaceVal map[string]interface{}
	}
	mock.lockWithFields.RLock()
	calls = mock.calls.WithFields
	mock.lockWithFields.RUnlock()
	return calls
}

// WithMonitoringEvent calls WithMonitoringEventFunc.
func (mock *LogEntryMock) WithMonitoringEvent(s1 string, s2 string, s3 string) LogEntry {
	if mock.WithMonitoringEventFunc == nil {
		panic("LogEntryMock.WithMonitoringEventFunc: method is nil but LogEntry.WithMonitoringEvent was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
		S3 string
	}{
		S1: s1,
		S2: s2,
		S3: s3,
	}
	mock.lockWithMonitoringEvent.Lock()
	mock.calls.WithMonitoringEvent = append(mock.calls.WithMonitoringEvent, callInfo)
	mock.lockWithMonitoringEvent.Unlock()
	return mock.WithMonitoringEventFunc(s1, s2, s3)
}

// WithMonitoringEventCalls gets all the calls that were made to WithMonitoringEvent.
// Check the length with:
//     len(mockedLogEntry.WithMonitoringEventCalls())
func (mock *LogEntryMock) WithMonitoringEventCalls() []struct {
	S1 string
	S2 string
	S3 string
} {
	var calls []struct {
		S1 string
		S2 string
		S3 string
	}
	mock.lockWithMonitoringEvent.RLock()
	calls = mock.calls.WithMonitoringEvent
	mock.lockWithMonitoringEvent.RUnlock()
	return calls
}

// WithTime calls WithTimeFunc.
func (mock *LogEntryMock) WithTime(timeMoqParam time.Time) LogEntry {
	if mock.WithTimeFunc == nil {
		panic("LogEntryMock.WithTimeFunc: method is nil but LogEntry.WithTime was just called")
	}
	callInfo := struct {
		TimeMoqParam time.Time
	}{
		TimeMoqParam: timeMoqParam,
	}
	mock.lockWithTime.Lock()
	mock.calls.WithTime = append(mock.calls.WithTime, callInfo)
	mock.lockWithTime.Unlock()
	return mock.WithTimeFunc(timeMoqParam)
}

// WithTimeCalls gets all the calls that were made to WithTime.
// Check the length with:
//     len(mockedLogEntry.WithTimeCalls())
func (mock *LogEntryMock) WithTimeCalls() []struct {
	TimeMoqParam time.Time
} {
	var calls []struct {
		TimeMoqParam time.Time
	}
	mock.lockWithTime.RLock()
	calls = mock.calls.WithTime
	mock.lockWithTime.RUnlock()
	return calls
}

// WithTransactionID calls WithTransactionIDFunc.
func (mock *LogEntryMock) WithTransactionID(s string) LogEntry {
	if mock.WithTransactionIDFunc == nil {
		panic("LogEntryMock.WithTransactionIDFunc: method is nil but LogEntry.WithTransactionID was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockWithTransactionID.Lock()
	mock.calls.WithTransactionID = append(mock.calls.WithTransactionID, callInfo)
	mock.lockWithTransactionID.Unlock()
	return mock.WithTransactionIDFunc(s)
}

// WithTransactionIDCalls gets all the calls that were made to WithTransactionID.
// Check the length with:
//     len(mockedLogEntry.WithTransactionIDCalls())
func (mock *LogEntryMock) WithTransactionIDCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockWithTransactionID.RLock()
	calls = mock.calls.WithTransactionID
	mock.lockWithTransactionID.RUnlock()
	return calls
}

// WithUUID calls WithUUIDFunc.
func (mock *LogEntryMock) WithUUID(s string) LogEntry {
	if mock.WithUUIDFunc == nil {
		panic("LogEntryMock.WithUUIDFunc: method is nil but LogEntry.WithUUID was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockWithUUID.Lock()
	mock.calls.WithUUID = append(mock.calls.WithUUID, callInfo)
	mock.lockWithUUID.Unlock()
	return mock.WithUUIDFunc(s)
}

// WithUUIDCalls gets all the calls that were made to WithUUID.
// Check the length with:
//     len(mockedLogEntry.WithUUIDCalls())
func (mock *LogEntryMock) WithUUIDCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockWithUUID.RLock()
	calls = mock.calls.WithUUID
	mock.lockWithUUID.RUnlock()
	return calls
}

// WithValidFlag calls WithValidFlagFunc.
func (mock *LogEntryMock) WithValidFlag(b bool) LogEntry {
	if mock.WithValidFlagFunc == nil {
		panic("LogEntryMock.WithValidFlagFunc: method is nil but LogEntry.WithValidFlag was just called")
	}
	callInfo := struct {
		B bool
	}{
		B: b,
	}
	mock.lockWithValidFlag.Lock()
	mock.calls.WithValidFlag = append(mock.calls.WithValidFlag, callInfo)
	mock.lockWithValidFlag.Unlock()
	return mock.WithValidFlagFunc(b)
}

// WithValidFlagCalls gets all the calls that were made to WithValidFlag.
// Check the length with:
//     len(mockedLogEntry.WithValidFlagCalls())
func (mock *LogEntryMock) WithValidFlagCalls() []struct {
	B bool
} {
	var calls []struct {
		B bool
	}
	mock.lockWithValidFlag.RLock()
	calls = mock.calls.WithValidFlag
	mock.lockWithValidFlag.RUnlock()
	return calls
}
