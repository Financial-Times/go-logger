// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logger

import (
	"sync"
	"time"
)

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
// 	func TestSomethingThatUsesLogger(t *testing.T) {
//
// 		// make and configure a mocked Logger
// 		mockedLogger := &LoggerMock{
// 			WithCategorisedEventFunc: func(s1 string, s2 string, s3 string, s4 string) LogEntry {
// 				panic("mock out the WithCategorisedEvent method")
// 			},
// 			WithErrorFunc: func(err error) LogEntry {
// 				panic("mock out the WithError method")
// 			},
// 			WithFieldFunc: func(s string, ifaceVal interface{}) LogEntry {
// 				panic("mock out the WithField method")
// 			},
// 			WithFieldsFunc: func(stringToIfaceVal map[string]interface{}) LogEntry {
// 				panic("mock out the WithFields method")
// 			},
// 			WithMonitoringEventFunc: func(s1 string, s2 string, s3 string) LogEntry {
// 				panic("mock out the WithMonitoringEvent method")
// 			},
// 			WithTimeFunc: func(timeMoqParam time.Time) LogEntry {
// 				panic("mock out the WithTime method")
// 			},
// 			WithTransactionIDFunc: func(s string) LogEntry {
// 				panic("mock out the WithTransactionID method")
// 			},
// 			WithUUIDFunc: func(s string) LogEntry {
// 				panic("mock out the WithUUID method")
// 			},
// 			WithValidFlagFunc: func(b bool) LogEntry {
// 				panic("mock out the WithValidFlag method")
// 			},
// 		}
//
// 		// use mockedLogger in code that requires Logger
// 		// and then make assertions.
//
// 	}
type LoggerMock struct {
	// WithCategorisedEventFunc mocks the WithCategorisedEvent method.
	WithCategorisedEventFunc func(s1 string, s2 string, s3 string, s4 string) LogEntry

	// WithErrorFunc mocks the WithError method.
	WithErrorFunc func(err error) LogEntry

	// WithFieldFunc mocks the WithField method.
	WithFieldFunc func(s string, ifaceVal interface{}) LogEntry

	// WithFieldsFunc mocks the WithFields method.
	WithFieldsFunc func(stringToIfaceVal map[string]interface{}) LogEntry

	// WithMonitoringEventFunc mocks the WithMonitoringEvent method.
	WithMonitoringEventFunc func(s1 string, s2 string, s3 string) LogEntry

	// WithTimeFunc mocks the WithTime method.
	WithTimeFunc func(timeMoqParam time.Time) LogEntry

	// WithTransactionIDFunc mocks the WithTransactionID method.
	WithTransactionIDFunc func(s string) LogEntry

	// WithUUIDFunc mocks the WithUUID method.
	WithUUIDFunc func(s string) LogEntry

	// WithValidFlagFunc mocks the WithValidFlag method.
	WithValidFlagFunc func(b bool) LogEntry

	// calls tracks calls to the methods.
	calls struct {
		// WithCategorisedEvent holds details about calls to the WithCategorisedEvent method.
		WithCategorisedEvent []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
			// S3 is the s3 argument value.
			S3 string
			// S4 is the s4 argument value.
			S4 string
		}
		// WithError holds details about calls to the WithError method.
		WithError []struct {
			// Err is the err argument value.
			Err error
		}
		// WithField holds details about calls to the WithField method.
		WithField []struct {
			// S is the s argument value.
			S string
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
		// WithFields holds details about calls to the WithFields method.
		WithFields []struct {
			// StringToIfaceVal is the stringToIfaceVal argument value.
			StringToIfaceVal map[string]interface{}
		}
		// WithMonitoringEvent holds details about calls to the WithMonitoringEvent method.
		WithMonitoringEvent []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
			// S3 is the s3 argument value.
			S3 string
		}
		// WithTime holds details about calls to the WithTime method.
		WithTime []struct {
			// TimeMoqParam is the timeMoqParam argument value.
			TimeMoqParam time.Time
		}
		// WithTransactionID holds details about calls to the WithTransactionID method.
		WithTransactionID []struct {
			// S is the s argument value.
			S string
		}
		// WithUUID holds details about calls to the WithUUID method.
		WithUUID []struct {
			// S is the s argument value.
			S string
		}
		// WithValidFlag holds details about calls to the WithValidFlag method.
		WithValidFlag []struct {
			// B is the b argument value.
			B bool
		}
	}
	lockWithCategorisedEvent sync.RWMutex
	lockWithError            sync.RWMutex
	lockWithField            sync.RWMutex
	lockWithFields           sync.RWMutex
	lockWithMonitoringEvent  sync.RWMutex
	lockWithTime             sync.RWMutex
	lockWithTransactionID    sync.RWMutex
	lockWithUUID             sync.RWMutex
	lockWithValidFlag        sync.RWMutex
}

// WithCategorisedEvent calls WithCategorisedEventFunc.
func (mock *LoggerMock) WithCategorisedEvent(s1 string, s2 string, s3 string, s4 string) LogEntry {
	if mock.WithCategorisedEventFunc == nil {
		panic("LoggerMock.WithCategorisedEventFunc: method is nil but Logger.WithCategorisedEvent was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
		S3 string
		S4 string
	}{
		S1: s1,
		S2: s2,
		S3: s3,
		S4: s4,
	}
	mock.lockWithCategorisedEvent.Lock()
	mock.calls.WithCategorisedEvent = append(mock.calls.WithCategorisedEvent, callInfo)
	mock.lockWithCategorisedEvent.Unlock()
	return mock.WithCategorisedEventFunc(s1, s2, s3, s4)
}

// WithCategorisedEventCalls gets all the calls that were made to WithCategorisedEvent.
// Check the length with:
//     len(mockedLogger.WithCategorisedEventCalls())
func (mock *LoggerMock) WithCategorisedEventCalls() []struct {
	S1 string
	S2 string
	S3 string
	S4 string
} {
	var calls []struct {
		S1 string
		S2 string
		S3 string
		S4 string
	}
	mock.lockWithCategorisedEvent.RLock()
	calls = mock.calls.WithCategorisedEvent
	mock.lockWithCategorisedEvent.RUnlock()
	return calls
}

// WithError calls WithErrorFunc.
func (mock *LoggerMock) WithError(err error) LogEntry {
	if mock.WithErrorFunc == nil {
		panic("LoggerMock.WithErrorFunc: method is nil but Logger.WithError was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockWithError.Lock()
	mock.calls.WithError = append(mock.calls.WithError, callInfo)
	mock.lockWithError.Unlock()
	return mock.WithErrorFunc(err)
}

// WithErrorCalls gets all the calls that were made to WithError.
// Check the length with:
//     len(mockedLogger.WithErrorCalls())
func (mock *LoggerMock) WithErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockWithError.RLock()
	calls = mock.calls.WithError
	mock.lockWithError.RUnlock()
	return calls
}

// WithField calls WithFieldFunc.
func (mock *LoggerMock) WithField(s string, ifaceVal interface{}) LogEntry {
	if mock.WithFieldFunc == nil {
		panic("LoggerMock.WithFieldFunc: method is nil but Logger.WithField was just called")
	}
	callInfo := struct {
		S        string
		IfaceVal interface{}
	}{
		S:        s,
		IfaceVal: ifaceVal,
	}
	mock.lockWithField.Lock()
	mock.calls.WithField = append(mock.calls.WithField, callInfo)
	mock.lockWithField.Unlock()
	return mock.WithFieldFunc(s, ifaceVal)
}

// WithFieldCalls gets all the calls that were made to WithField.
// Check the length with:
//     len(mockedLogger.WithFieldCalls())
func (mock *LoggerMock) WithFieldCalls() []struct {
	S        string
	IfaceVal interface{}
} {
	var calls []struct {
		S        string
		IfaceVal interface{}
	}
	mock.lockWithField.RLock()
	calls = mock.calls.WithField
	mock.lockWithField.RUnlock()
	return calls
}

// WithFields calls WithFieldsFunc.
func (mock *LoggerMock) WithFields(stringToIfaceVal map[string]interface{}) LogEntry {
	if mock.WithFieldsFunc == nil {
		panic("LoggerMock.WithFieldsFunc: method is nil but Logger.WithFields was just called")
	}
	callInfo := struct {
		StringToIfaceVal map[string]interface{}
	}{
		StringToIfaceVal: stringToIfaceVal,
	}
	mock.lockWithFields.Lock()
	mock.calls.WithFields = append(mock.calls.WithFields, callInfo)
	mock.lockWithFields.Unlock()
	return mock.WithFieldsFunc(stringToIfaceVal)
}

// WithFieldsCalls gets all the calls that were made to WithFields.
// Check the length with:
//     len(mockedLogger.WithFieldsCalls())
func (mock *LoggerMock) WithFieldsCalls() []struct {
	StringToIfaceVal map[string]interface{}
} {
	var calls []struct {
		StringToIfaceVal map[string]interface{}
	}
	mock.lockWithFields.RLock()
	calls = mock.calls.WithFields
	mock.lockWithFields.RUnlock()
	return calls
}

// WithMonitoringEvent calls WithMonitoringEventFunc.
func (mock *LoggerMock) WithMonitoringEvent(s1 string, s2 string, s3 string) LogEntry {
	if mock.WithMonitoringEventFunc == nil {
		panic("LoggerMock.WithMonitoringEventFunc: method is nil but Logger.WithMonitoringEvent was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
		S3 string
	}{
		S1: s1,
		S2: s2,
		S3: s3,
	}
	mock.lockWithMonitoringEvent.Lock()
	mock.calls.WithMonitoringEvent = append(mock.calls.WithMonitoringEvent, callInfo)
	mock.lockWithMonitoringEvent.Unlock()
	return mock.WithMonitoringEventFunc(s1, s2, s3)
}

// WithMonitoringEventCalls gets all the calls that were made to WithMonitoringEvent.
// Check the length with:
//     len(mockedLogger.WithMonitoringEventCalls())
func (mock *LoggerMock) WithMonitoringEventCalls() []struct {
	S1 string
	S2 string
	S3 string
} {
	var calls []struct {
		S1 string
		S2 string
		S3 string
	}
	mock.lockWithMonitoringEvent.RLock()
	calls = mock.calls.WithMonitoringEvent
	mock.lockWithMonitoringEvent.RUnlock()
	return calls
}

// WithTime calls WithTimeFunc.
func (mock *LoggerMock) WithTime(timeMoqParam time.Time) LogEntry {
	if mock.WithTimeFunc == nil {
		panic("LoggerMock.WithTimeFunc: method is nil but Logger.WithTime was just called")
	}
	callInfo := struct {
		TimeMoqParam time.Time
	}{
		TimeMoqParam: timeMoqParam,
	}
	mock.lockWithTime.Lock()
	mock.calls.WithTime = append(mock.calls.WithTime, callInfo)
	mock.lockWithTime.Unlock()
	return mock.WithTimeFunc(timeMoqParam)
}

// WithTimeCalls gets all the calls that were made to WithTime.
// Check the length with:
//     len(mockedLogger.WithTimeCalls())
func (mock *LoggerMock) WithTimeCalls() []struct {
	TimeMoqParam time.Time
} {
	var calls []struct {
		TimeMoqParam time.Time
	}
	mock.lockWithTime.RLock()
	calls = mock.calls.WithTime
	mock.lockWithTime.RUnlock()
	return calls
}

// WithTransactionID calls WithTransactionIDFunc.
func (mock *LoggerMock) WithTransactionID(s string) LogEntry {
	if mock.WithTransactionIDFunc == nil {
		panic("LoggerMock.WithTransactionIDFunc: method is nil but Logger.WithTransactionID was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockWithTransactionID.Lock()
	mock.calls.WithTransactionID = append(mock.calls.WithTransactionID, callInfo)
	mock.lockWithTransactionID.Unlock()
	return mock.WithTransactionIDFunc(s)
}

// WithTransactionIDCalls gets all the calls that were made to WithTransactionID.
// Check the length with:
//     len(mockedLogger.WithTransactionIDCalls())
func (mock *LoggerMock) WithTransactionIDCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockWithTransactionID.RLock()
	calls = mock.calls.WithTransactionID
	mock.lockWithTransactionID.RUnlock()
	return calls
}

// WithUUID calls WithUUIDFunc.
func (mock *LoggerMock) WithUUID(s string) LogEntry {
	if mock.WithUUIDFunc == nil {
		panic("LoggerMock.WithUUIDFunc: method is nil but Logger.WithUUID was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockWithUUID.Lock()
	mock.calls.WithUUID = append(mock.calls.WithUUID, callInfo)
	mock.lockWithUUID.Unlock()
	return mock.WithUUIDFunc(s)
}

// WithUUIDCalls gets all the calls that were made to WithUUID.
// Check the length with:
//     len(mockedLogger.WithUUIDCalls())
func (mock *LoggerMock) WithUUIDCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockWithUUID.RLock()
	calls = mock.calls.WithUUID
	mock.lockWithUUID.RUnlock()
	return calls
}

// WithValidFlag calls WithValidFlagFunc.
func (mock *LoggerMock) WithValidFlag(b bool) LogEntry {
	if mock.WithValidFlagFunc == nil {
		panic("LoggerMock.WithValidFlagFunc: method is nil but Logger.WithValidFlag was just called")
	}
	callInfo := struct {
		B bool
	}{
		B: b,
	}
	mock.lockWithValidFlag.Lock()
	mock.calls.WithValidFlag = append(mock.calls.WithValidFlag, callInfo)
	mock.lockWithValidFlag.Unlock()
	return mock.WithValidFlagFunc(b)
}

// WithValidFlagCalls gets all the calls that were made to WithValidFlag.
// Check the length with:
//     len(mockedLogger.WithValidFlagCalls())
func (mock *LoggerMock) WithValidFlagCalls() []struct {
	B bool
} {
	var calls []struct {
		B bool
	}
	mock.lockWithValidFlag.RLock()
	calls = mock.calls.WithValidFlag
	mock.lockWithValidFlag.RUnlock()
	return calls
}
